<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>思索 2023.11.15</title>
    <link href="/2023/11/15/%E6%80%9D%E7%B4%A2%202023.11.15/"/>
    <url>/2023/11/15/%E6%80%9D%E7%B4%A2%202023.11.15/</url>
    
    <content type="html"><![CDATA[<h1 id="随心所欲不逾矩">随心所欲不逾矩</h1><p>生活需要一种节奏，有慢有快，有放松有紧张，有随心也有自律。</p><p>长久的放松不是真正的生活，而是一种放纵，只会愈发的感觉到空虚。</p><p>我常常在想，电子ED或者突如其来的空虚感，其实是一种焦虑，越是放纵的游戏，就越是空虚，这就是失去了生活的节奏。因为人对于愉悦的感知应该是指数性的，每一次愉悦到下一次愉悦都需要指数级的提升，而满足愉悦需求的阈值函数应该是一个类sigmoid的函数，这就导致不间断的刺激需要的阈值指数级增长，而进一步地导致空虚感的产生。</p><p>可能这就是为什么越是放纵越是空虚。</p><p>为此，我们需要调整自己的生活节奏，需要工作，需要适度的“痛苦”来调节自己的愉悦阈值，这也是高难度工作完成后满足感极强的一类原因吧。</p><p>古语讲：“随心所欲不逾矩”，个人理解，这里的随心所欲应该就是随心而动，认清自己的真实需求，不逾矩就是符合规则，有条理，有节律，对自我的欲望有管控。如此，才不会欲壑难填，沦为人性的奴隶。</p><p>故，需要让生活变得有计划，有节律，才能获得真正的享受，持续的享受，高级的享受。</p><p>第一次开始记录心路历程，希望日后回顾，能不带遗憾地说：“这里是我重新起航的地方，是我的人生第一次由自己掌托的时刻。”</p><blockquote><p>为岁月干杯！</p><p>另：芙芙可爱捏。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
    <tags>
      
      <tag>思索</tag>
      
      <tag>记录，自律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>COMSOL薄膜电容仿真</title>
    <link href="/2023/06/25/COMSOL%E8%96%84%E8%86%9C%E7%94%B5%E5%AE%B9%E4%BB%BF%E7%9C%9F/"/>
    <url>/2023/06/25/COMSOL%E8%96%84%E8%86%9C%E7%94%B5%E5%AE%B9%E4%BB%BF%E7%9C%9F/</url>
    
    <content type="html"><![CDATA[<h1 id="comsol薄膜电容仿真">COMSOL薄膜电容仿真</h1><p>在RF等领域的芯片设计中，经常遇到平面电路的电容仿真等问题，这里以COMSOL为演示，作为一种ANSYSMaxwell模块的替代。</p><h2 id="环境">环境</h2><ul><li>Windows 11 专业版 22H2 22621.1848</li><li>AMD Ryzen 5 3600 6-Core Processor 3.60 GHz</li><li>16Gx4 3200MHz</li><li>COMSOL 6.1</li></ul><h2 id="gdsii">GDSII</h2><figure><img src="image-20230625150034672.png" alt="image-20230625150034672" /><figcaption aria-hidden="true">image-20230625150034672</figcaption></figure><h2 id="comsol">COMSOL</h2><h3 id="建立项目">建立项目</h3><p>点击<code>模型向导</code>,选择<code>三维</code></p><figure><img src="image-20230625150514334.png" alt="image-20230625150514334" /><figcaption aria-hidden="true">image-20230625150514334</figcaption></figure><figure><img src="image-20230625150542294.png" alt="image-20230625150542294" /><figcaption aria-hidden="true">image-20230625150542294</figcaption></figure><p>选择<code>AC/DC</code>分类中的<code>电场和电流</code>下的<code>静电(es)</code>物理场，点击<code>添加</code>物理场接口</p><figure><img src="image-20230625150840079.png" alt="image-20230625150840079" /><figcaption aria-hidden="true">image-20230625150840079</figcaption></figure><p>在研究面板中选择<code>一般研究</code>下的<code>稳态</code>，然后点击完成</p><figure><img src="image-20230625151009386.png" alt="image-20230625151009386" /><figcaption aria-hidden="true">image-20230625151009386</figcaption></figure><p>进入到如下所示项目主界面</p><figure><img src="image-20230625151259314.png" alt="image-20230625151259314" /><figcaption aria-hidden="true">image-20230625151259314</figcaption></figure><h3 id="构建模型">构建模型</h3><h4 id="导入gdsii">导入GDSII</h4><p><code>几何</code>-&gt;<code>导入</code>-&gt;<code>浏览</code>-&gt;选择需要导入的GDSII文件</p><figure><img src="image-20230625151544430.png" alt="image-20230625151544430" /><figcaption aria-hidden="true">image-20230625151544430</figcaption></figure><figure><img src="image-20230625151703196.png" alt="image-20230625151703196" /><figcaption aria-hidden="true">image-20230625151703196</figcaption></figure><p>修改厚度为需要仿真的厚度，这里选择100nm</p><blockquote><p><strong>TIPS</strong></p><p>如果需要导入多层图，勾选<code>手动控制高度</code>并设置好参数</p><p>对于存在多个图层的GDSII文件，建议勾选<code>按数据类型拆分</code>来导入具体的图层</p></blockquote><p>点击<code>构建选定对象</code>完成电容电路的模型构建</p><figure><img src="image-20230625152319370.png" alt="image-20230625152319370" /><figcaption aria-hidden="true">image-20230625152319370</figcaption></figure><h4 id="绘制衬底">绘制衬底</h4><p><code>几何</code>-&gt;<code>长方体</code></p><p>我们这里选择使用一块 500um x 500um x 450um 的长方体衬底</p><p>位置栏目下，基准选择<code>居中</code>，并填写对应的坐标，以确保衬底上表面与电路下表面正好接触</p><p>点击<code>构建选定对象</code>以生成模型，并点击右侧图形窗口中的<code>缩放到窗口大小</code>图标以缩放到合适大小</p><figure><img src="image-20230625152801832.png" alt="image-20230625152801832" /><figcaption aria-hidden="true">image-20230625152801832</figcaption></figure><blockquote><p><strong>TIPS</strong></p><p>对于比较复杂或者比较大的电路，建议扩大衬底以较好的近似真实情况</p></blockquote><h4 id="添加空气域">添加“空气域”</h4><p><code>几何</code>-&gt;<code>球体</code></p><p>设定好<code>半径</code>参数后，点击右侧图形窗口的对应按钮，设为线框渲染并缩放到窗口大小</p><figure><img src="image-20230625153636632.png" alt="image-20230625153636632" /><figcaption aria-hidden="true">image-20230625153636632</figcaption></figure><h3 id="添加材料">添加材料</h3><p><code>材料</code>-&gt;<code>空材料</code></p><p>修改标签为<code>pec</code>，手动去除掉不需要添加理想导体的域（<code>1</code>，<code>2</code>）,相对介电常数这里保持默认的各向同性设置，填写具体值为<code>1</code></p><figure><img src="image-20230625154128623.png" alt="image-20230625154128623" /><figcaption aria-hidden="true">image-20230625154128623</figcaption></figure><p>同理，我们给衬底加上相对介电常数为9.3的c-plane蓝宝石材料以及给“空气域”加上相对介电常数为1的真空材料</p><h3 id="设置物理场">设置物理场</h3><p>为了在后续仿真结果中提取Maxwell电容矩阵，我们需要给两块极板分别加上一个监测用的终端并设置静电场仿真的参数扫描</p><h4 id="添加域终端">添加域终端</h4><p><code>物理场</code>-&gt;<code>域</code>-&gt;<code>终端</code></p><p>在域选择栏目中，选择<code>LAYER1(导入1)</code>来快速选中两块极板，并手动去除其中一块的选择</p><p>修改终端类型为<code>电压</code></p><figure><img src="image-20230625155849037.png" alt="image-20230625155849037" /><figcaption aria-hidden="true">image-20230625155849037</figcaption></figure><p>类似地，再添加一个终端并在域选择中选中另一块极板</p><figure><img src="image-20230625160253046.png" alt="image-20230625160253046" /><figcaption aria-hidden="true">image-20230625160253046</figcaption></figure><blockquote><p><strong>TIPS</strong></p><p>对于多块极板间的Maxwell电容矩阵的提取，每块极板都需要设置一个对应的电压类型的终端</p><p>终端设置面板中的<code>终端名称</code>就是等下需要做参数扫描的值</p><p><code>终端类型</code>决定了提取的是Maxwell电容矩阵还是Maxwell逆电容矩阵</p></blockquote><h4 id="设置终端扫描">设置终端扫描</h4><p>在静电场仿真的设置面板中勾选使用<code>手动终端扫描</code>，并复制其自动生成的扫描参数名称（这里是<code>TerminalName</code>）</p><figure><img src="image-20230625160553666.png" alt="image-20230625160553666" /><figcaption aria-hidden="true">image-20230625160553666</figcaption></figure><p>然后在<code>全局定义</code>的<code>参数1</code>下面设置一个全局参数</p><figure><img src="image-20230625160757902.png" alt="image-20230625160757902" /><figcaption aria-hidden="true">image-20230625160757902</figcaption></figure><h3 id="划分计算网格">划分计算网格</h3><p>通常而言，我们可以点击<code>网格1</code>设置面板中的<code>全部构建</code>来使用物理场控制的默认网格，但是我们这里的模型几何尺寸比例过于极端，自动划分的体网格很容易在极板上产生低质量网格，影响场分布计算的准确度，但是对于估算的电容矩阵而言一般影响有限，这里还是演示一下如何进行手动划分网格。</p><p>我们整体的网格划分思路为对表面电路进行扫掠网格划分，对衬底和“空气域”采用自由四面体网格</p><p>这样可以给表面电路提供较精确的计算保证同时减少不必要的计算来提高计算速度</p><blockquote><p>高版本COMSOL求解器中还有自适应网格优化的设置，也可以考虑使用</p></blockquote><h4 id="添加边界网格划分">添加边界网格划分</h4><p><code>网格</code>-&gt;<code>边界</code>-&gt;<code>自由四边形网格</code></p><p>选中两块极板的上表面</p><figure><img src="image-20230625161911507.png" alt="image-20230625161911507" /><figcaption aria-hidden="true">image-20230625161911507</figcaption></figure><blockquote><p><strong>TIPS</strong></p><p>在右侧的图形窗口中，滚动滚轮可以实现鼠标对当前位置不同几何层的选择，依据窗口左上角的提示，即可选择上表面</p><figure><img src="image-20230625162046616.png" alt="image-20230625162046616" /><figcaption aria-hidden="true">image-20230625162046616</figcaption></figure></blockquote><p>右键<code>自由四边形网格1</code>添加两个<code>分布</code>节点用于手动控制网格的细化方案</p><p>以第一个分布为例，选择两块极板的上表面的长边，分布类型选择<code>预定义</code></p><p>单元数设置为<code>200</code>，单元大小比设置为<code>50</code>（可自行调整来绘制比较干净的网格，也可不使用分布节点而是通过大小节点来绘制）</p><p>增长率设置为<code>指数</code>，勾选<code>对称分布</code></p><figure><img src="image-20230625162953560.png" alt="image-20230625162953560" /><figcaption aria-hidden="true">image-20230625162953560</figcaption></figure><p>另一个分布选择四条短边，最后选择构建选定对象，我们就获得了一个边缘细化中间粗化的表面网格</p><h4 id="构建极板扫掠网格">构建极板扫掠网格</h4><p><code>网格</code>-&gt;<code>扫掠</code></p><p>域选择中，几何实体层设置为<code>域</code>，选择两块极板</p><p>源面选择两块极板的上表面，目标面选择两块极板的下表面</p><p>点击<code>构建选定对象</code>即可完成极板的扫掠网格构建（可以添加分布节点来调节扫掠的层数，这里由于网格父节点的设置，自动只创建了一层，不过计算精度应该是够用的）</p><figure><img src="image-20230625163542342.png" alt="image-20230625163542342" /><figcaption aria-hidden="true">image-20230625163542342</figcaption></figure><h4 id="剩余几何体自由四面体网格划分">剩余几何体自由四面体网格划分</h4><p><code>网格</code>-&gt; <code>自由四面体网格</code></p><p>默认的集合实体层选择的是<code>剩余部分</code>，保持默认即可</p><figure><img src="image-20230625164006696.png" alt="image-20230625164006696" /><figcaption aria-hidden="true">image-20230625164006696</figcaption></figure><p>点击<code>构建选定对象</code>，等网格构建完成</p><p>点击右侧图形窗口的<code>透明</code>图标，可以使得渲染半透明化，方便观察网格划分</p><p>右键<code>网格1</code>，选择<code>网格信息</code>可以查看网格划分的质量统计</p><figure><img src="image-20230625164554827.png" alt="image-20230625164554827" /><figcaption aria-hidden="true">image-20230625164554827</figcaption></figure><p>这里<code>自由四面体网格1</code>有信息子节点显示存在9个低质量单元，可以继续优化网格，但是我们先不管了。</p><figure><img src="image-20230625164722797.png" alt="image-20230625164722797" /><figcaption aria-hidden="true">image-20230625164722797</figcaption></figure><h3 id="设置研究">设置研究</h3><p><code>研究</code>-&gt; <code>参数化扫描</code></p><p>添加之前在全局参数中设置的终端扫描参数，参数值列表填写<code>1 2</code>，也就之前的终端名称</p><figure><img src="image-20230625165433756.png" alt="image-20230625165433756" /><figcaption aria-hidden="true">image-20230625165433756</figcaption></figure><h3 id="计算">计算</h3><p>点击研究左上角的计算即可开始仿真</p><figure><img src="image-20230625165844249.png" alt="image-20230625165844249" /><figcaption aria-hidden="true">image-20230625165844249</figcaption></figure><p>计算完成后会自动绘制电势图</p><figure><img src="image-20230625170113891.png" alt="image-20230625170113891" /><figcaption aria-hidden="true">image-20230625170113891</figcaption></figure><h4 id="提取maxwell电容矩阵">提取Maxwell电容矩阵</h4><p>右键<code>派生值</code>，选择<code>全局矩阵计算</code></p><p>数据集选择<code>研究1/参数化解 1(sol2)</code>，参数选择保持默认的<code>全部</code></p><p>在表达式中添加<code>es.C - 麦克斯韦电容 - F</code></p><figure><img src="image-20230625170538768.png" alt="image-20230625170538768" /><figcaption aria-hidden="true">image-20230625170538768</figcaption></figure><p>单位修改为<code>fF</code></p><p>点击<code>计算</code>，右下角即会出现表格展示出Maxwell电容矩阵</p><figure><img src="image-20230625170928396.png" alt="image-20230625170928396" /><figcaption aria-hidden="true">image-20230625170928396</figcaption></figure><p>可以得到</p><table><thead><tr class="header"><th>Maxwell电容矩阵</th><th>1</th><th>2</th></tr></thead><tbody><tr class="odd"><td>1</td><td>17.523</td><td>-17.523</td></tr><tr class="even"><td>2</td><td>-17.523</td><td>17.523</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>仿真</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qubit</tag>
      
      <tag>超导量子计算</tag>
      
      <tag>COMSOL</tag>
      
      <tag>电容仿真</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VSCodeJupyter的交互式绘图配置</title>
    <link href="/2023/06/16/VSCodeJupyter%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BB%98%E5%9B%BE%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/06/16/VSCodeJupyter%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BB%98%E5%9B%BE%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1id="vscodejupyter的交互式绘图配置">VSCodeJupyter的交互式绘图配置</h1><h2 id="安装支持库">安装支持库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install ipympl<br></code></pre></td></tr></table></figure><p>安装完成后需要重启Jupyter服务</p><h2 id="vscode使用">VSCode使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib widget <span class="hljs-comment"># 切换 matplotlib 的绘图后端为 ipympl</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h2 id="demo">Demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib widget<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">time = [<span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">240</span>, <span class="hljs-number">360</span>, <span class="hljs-number">390</span>]<br>plt.figure()<br>plt.plot(time,[<span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">23</span>])<br>plt.xticks([<span class="hljs-number">180</span>, <span class="hljs-number">240</span>, <span class="hljs-number">360</span>, <span class="hljs-number">390</span>], [<span class="hljs-string">&quot;3:00&quot;</span>,<span class="hljs-string">&quot;4:00&quot;</span>,<span class="hljs-string">&quot;6:00&quot;</span>,<span class="hljs-string">&quot;6:30&quot;</span>])<br>plt.title(<span class="hljs-string">&quot;Before Deposition&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Power&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/img/md/image-20230616183028835.png"alt="image-20230616183028835" /><figcaption aria-hidden="true">image-20230616183028835</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">time = [<span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>plt.figure()<br>plt.plot(time,[<span class="hljs-number">23</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>])<br>plt.xticks([<span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>], [<span class="hljs-string">&quot;0:30&quot;</span>,<span class="hljs-string">&quot;0:50&quot;</span>,<span class="hljs-string">&quot;1:00&quot;</span>])<br>plt.title(<span class="hljs-string">&quot;After Deposition&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Power&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/img/md/image-20230616183059631.png"alt="image-20230616183059631" /><figcaption aria-hidden="true">image-20230616183059631</figcaption></figure><h2 id="注意事项">注意事项</h2><p>每次绘图时需要多加一行代码，用于创建一个新的画布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure()<br></code></pre></td></tr></table></figure><p>如果不新建画布，会导致不同cell之间的plt绘图共用同一张画布</p><p><em>也可以使用ax的方式绘图</em></p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Jupyter</tag>
      
      <tag>Matplotlib</tag>
      
      <tag>ipympl</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超导量子计算常用物理常数</title>
    <link href="/2023/05/21/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E7%89%A9%E7%90%86%E5%B8%B8%E6%95%B0/"/>
    <url>/2023/05/21/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E7%89%A9%E7%90%86%E5%B8%B8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="超导量子计算常用物理常数">超导量子计算常用物理常数</h1><table><thead><tr class="header"><th>常数</th><th>符号</th><th>数值</th></tr></thead><tbody><tr class="odd"><td>约化普朗克常数</td><td><span class="math inline">\(\hbar\)</span></td><td><span class="math inline">\(1.055\times10^{-34}J\cdots\)</span></td></tr><tr class="even"><td>电子电荷</td><td><span class="math inline">\(e\)</span></td><td><span class="math inline">\(1.602\times10^{-19}C\)</span></td></tr><tr class="odd"><td>磁通量子</td><td><span class="math inline">\(\Phi_0\)</span></td><td><span class="math inline">\(2.068\times10^{-15}Wb\)</span></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qubit</tag>
      
      <tag>超导量子计算</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑塔情诗</title>
    <link href="/2023/05/21/%E9%BB%91%E5%A1%94%E6%83%85%E8%AF%97/"/>
    <url>/2023/05/21/%E9%BB%91%E5%A1%94%E6%83%85%E8%AF%97/</url>
    
    <content type="html"><![CDATA[<p>当爱情踏上旅途 当时间燃尽壁炉 当一条去咖啡馆的路 要从婴孩走向坟墓当一次恋人的期待 要用一生去满足 你当出发？ 还是止步 ———— <ahref="https://www.bilibili.com/video/BV1Mv4y1J7xU">【基德】用相对论玩星穹铁道by 吟游诗人·基德</a></p>]]></content>
    
    
    <categories>
      
      <category>诗与歌与远方</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超导量子计算导论</title>
    <link href="/2023/05/17/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA/"/>
    <url>/2023/05/17/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="量子计算简介">量子计算简介</h1><h3 id="bloch球">Bloch球</h3><p>量子比特的纯态可以用Bloch球表示</p><figure><img src="/img/md/20220214224730.png" alt="20220214224730" /><figcaption aria-hidden="true">20220214224730</figcaption></figure><p><span class="math display">\[\ket{\psi}=\cos({\theta\over2})\ket{0}+e^{i\phi}\sin({\theta\over2})\ket{1}\]</span> 注意这里的<spanclass="math inline">\(\theta\)</span>会和布居数（占据数）联系，<spanclass="math inline">\(\phi\)</span>则是相对相位（这很显然）</p><h3 id="旋转操作算符">旋转操作算符</h3><p>考虑对一个量子态在Bloch球上进行旋转操作，旋转轴为<spanclass="math inline">\(\vec{n}\)</span>，旋转角度为<spanclass="math inline">\(\alpha\)</span> 记为 <span class="math display">\[\hat{U}=\hat{U}(\vec{n},\alpha)=e^{-i\alpha{\vec{n}\cdot\hat{\vec{S}}\over\hbar}}\]</span> 对于Bloch球表示的体系，<spanclass="math inline">\(\hat{\vec{S}}={\hbar\over2}\hat{\vec{\sigma}}\)</span>所以我们可以得到旋转操作算符 <span class="math display">\[\hat{U}(\vec{n},\alpha)=e^{-i{\alpha\over2}\vec{n}\cdot\hat{\vec{\sigma}}}=\cos({\alpha\over2})-i\vec{n}\cdot\hat{\vec{\sigma}}\sin({\alpha\over2})\]</span> 这里已经利用了扩展的欧拉公式，其中<spanclass="math inline">\((\vec{n}\cdot\hat{\vec{\sigma}})^2=\hat{I}\)</span>证明如下 <span class="math display">\[\hat{q}^2=\hat{I}\]</span></p><p><span class="math display">\[e^{i\theta\hat{q}}=\sum_{k=0}^\infty[{(-1)^k\theta^{2k}\over(2k)!}+i\hat{q}{(-1)^k\theta^{2k+1}\over(2k+1)!}]=\cos\theta+i\hat{q}\sin\theta\]</span></p><h2 id="lc振荡电路及其量子化">LC振荡电路及其量子化</h2><figure><img src="/img/md/lc.gif" alt="lc" /><figcaption aria-hidden="true">lc</figcaption></figure><figure><img src="/img/md/20220512224156.png" alt="20220512224156" /><figcaption aria-hidden="true">20220512224156</figcaption></figure><p>系统的哈密顿量为 <span class="math display">\[H = {Q^2\over2C}+{\Phi^2\over2L}\]</span> 其中<spanclass="math inline">\(Q\)</span>是电容的电荷量，<spanclass="math inline">\(\Phi\)</span>是电感的磁通量 使用基本电荷<spanclass="math inline">\(e\)</span>和磁通量子<spanclass="math inline">\(\Phi_0={h\over2e}\)</span>改写，<spanclass="math inline">\(n={Q\over2e}, ~\phi={2\pi\Phi\over\Phi_0}={4\pie\Phi\over h}\)</span>可以有 <span class="math display">\[H = 4{e^2\over2C}n^2+{(\Phi_0/2\pi)^2\over2L}\phi^2\]</span> 可以进一步得到 <span class="math display">\[E_C = {e^2\over2C}~~~~E_L={(\Phi_0/2\pi)^2\over2L}\]</span>分别代表一个电荷所带来的电容器上的能量，以及一个磁通量子所带来的电感上的能量量子化后有 <span class="math display">\[H=4E_C\hat{n}^2+E_L\hat{\phi}^2\]</span></p><p><span class="math display">\[[\hat \phi, \hat n]=i\]</span></p><h2 id="约瑟夫森结">约瑟夫森结</h2><figure><img src="/img/md/20220215005311.png" alt="20220215005311" /><figcaption aria-hidden="true">20220215005311</figcaption></figure><p>约瑟夫森结由两层超导体夹着一层绝缘体组成，其行为由约瑟夫森方程决定：<span class="math display">\[V(t)={\mathrm{d}\Phi(t)\over\mathrm{d}t}\]</span></p><p><span class="math display">\[I(t)=I_s\sin(2\pi{\Phi(t)\over\Phi_0})\]</span></p><p>其中，<spanclass="math inline">\(\Phi\)</span>是以磁通量子为单位来描述的两超导体之间的序参量位相差</p><h3 id="直流伏安特性">直流伏安特性</h3><p>当偏置电流从0开始增大，结两端的电压一直为0，直到电流大于临界电流<spanclass="math inline">\(I_s\)</span>，此时结两端突然出现电压<spanclass="math inline">\(V=2\Delta/e\)</span>，其中<spanclass="math inline">\(\Delta\)</span>是材料的超导能隙；继续增大电流，系统表现出正常电阻状态；减小偏置电压至<spanclass="math inline">\(2\Delta/e\)</span>，结两端电流减小至<spanclass="math inline">\(I_s\)</span>；电压继续减小，电流一直保持在<spanclass="math inline">\(I_s\)</span>，直到电压减小为0。</p><h3 id="等效电感">等效电感</h3><p><span class="math display">\[L = {V\over\dot I}={\Phi_0\over2\pi I_s\cos(2\pi{\Phi(t)\over\Phi_0})}\]</span></p><p>可以看到，对于一个约瑟夫森结，可以等效的看作有一个非线性的电感存在。其包含的能量可以计算为 <span class="math display">\[E = \int IV\mathrm dt ={I_s\Phi_0\over2\pi}\int\sin(2\pi{\Phi(t)\over\Phi_0}){\mathrm{d}\Phi(t)\over\mathrm{d}t}\mathrmdt=-{I_s\Phi_0\over2\pi}\cos(2\pi{\Phi(t)\over\Phi_0})\]</span> 有 <span class="math display">\[E_J = {I_s\Phi_0\over2\pi}\]</span>表示一个磁通量子在约瑟夫森结中所带来的能量，考虑到和电荷能的对偶关系，可以认为是一对电子（一个库伯对）穿越约瑟夫森结时所需的能量考虑仅含一个约瑟夫森结的闭合回路，由于结自身所带的电容<spanclass="math inline">\(C\)</span>，这构成了一个LC振荡电路，我们依据之前的关系，可以得到<span class="math display">\[H =4E_C\hat{n}^2-E_J\cos(2\pi{\hat\Phi(t)\over\Phi_0})=4E_C\hat{n}^2-E_J\cos\hat\phi\]</span></p><h3 id="dc-squid">DC-SQUID</h3><figure><img src="/img/md/20220506170057.png" alt="20220506170057" /><figcaption aria-hidden="true">20220506170057</figcaption></figure><p>依照约瑟夫森结方程 <span class="math display">\[I=I_a\sin\phi_a+I_b\sin\phi_b\]</span> 考虑a结和b结相同，则有 <span class="math display">\[\begin{align*}I &amp;= I_a(\sin\phi_a+\sin\phi_b)\\&amp;= 2I_a\cos({\phi_a-\phi_b\over2})\sin({\phi_a+\phi_b\over2})\\&amp;= I_c\sin(\phi)\end{align*}\\\]</span> 考虑环形回路中有偏置磁通量<spanclass="math inline">\(\Phi_c\)</span> 由<spanclass="math inline">\(\hbar\nabla\psi=2e\vec{A}\)</span>有： <spanclass="math display">\[\begin{align*}\int_{SQUID}\hbar\nabla\phi\cdot\mathrm d\vec l = \int_{SQUID}2e\vecA\cdot\mathrm d\vec l\\\Longrightarrow\hbar(\phi_a-\phi_b)=2e\cdot\Phi_c\end{align*}\]</span> 由此我们得到： <span class="math display">\[I_c=2I_a\cos({2e\cdot\Phi_c\over2\hbar})=2I_a\cos(\pi\cdot{2e\overh}\cdot\Phi_c)=2I_a\cos(\pi{\Phi_c\over\Phi_0})\]</span> 最终，DC-SQUID和一个电容形成的超导回路，满足 <spanclass="math display">\[\begin{align*}H=4E_c\hat n^2-2E_{J, c}\cos\hat \phi\\E_{J, c}=E_J\cos(\pi\cdot{\Phi_c\over\Phi_0})\end{align*}\]</span> 所以，如果我们调控偏置磁通量<spanclass="math inline">\(\Phi_c\)</span>，就能够人为的调控等效约瑟夫森结的电流<spanclass="math inline">\(I_c\)</span>，也就能调控<spanclass="math inline">\(E_{J, c}\)</span>，进而可以调控比特频率</p><h2 id="qubit-architecture">Qubit Architecture</h2><h3 id="cpbcooper-pair-box">CPB(Cooper Pair Box)</h3><figure><img src="/img/md/cpb.png" alt="cpb" /><figcaption aria-hidden="true">cpb</figcaption></figure><figure><img src="/img/md/20220506165827.png" alt="20220506165827" /><figcaption aria-hidden="true">20220506165827</figcaption></figure><p>系统的广义动能项为 <span class="math display">\[T={C_g\over2}\dot\phi_J^2+{C_J\over2}\dot\phi_J^2={C_\Sigma\over2}\dot\phi_J^2\]</span> 其中<spanclass="math inline">\(C_\Sigma=C_g+C_J\)</span>表征系统的总体电容值，代表了CPB的电荷储能能力以及系统量子态对电荷的敏感程度CPB的广义势能项包括两个部分，约瑟夫森结的等效电感储能以及外部给予的电势能<span class="math display">\[U = -E_J\cos({2\pi\over\Phi_0}\phi_J)-V_gC_g\dot\phi_J\]</span> 可以得到CPB的哈密顿量为 <span class="math display">\[H = {(Q_J-C_gV_g)^2\over2C_\Sigma}-E_J\cos({2\pi\over\Phi_0}\phi_J)\]</span></p><h3 id="capacitive-shunted-cpb">Capacitive-shunted CPB</h3><p>出于压制电荷噪声的考虑，可以提高CPB中的<spanclass="math inline">\(C_\Sigma\)</span>，因此加上一个旁接在结上的大电容<spanclass="math inline">\(C_{sh}\)</span>。</p><p>满足条件<span class="math inline">\(C_{sh}\gg C_J\)</span></p><h2 id="cavity-qed">Cavity QED</h2><h3 id="重要的数学前提">重要的数学前提</h3><p><span class="math display">\[[a^\dagger, a]=-1\]</span></p><p><span class="math display">\[\sigma_z=\left[\begin{matrix}1 &amp; 0\\ 0 &amp;-1\end{matrix}\right]~~~~\sigma_x=\left[\begin{matrix}0 &amp; 1\\ 1 &amp;0\end{matrix}\right]~~~~\sigma_y=\left[\begin{matrix}0 &amp; - i\\ i &amp; 0\end{matrix}\right]\]</span></p><p><span class="math display">\[\sigma^+=\left[\begin{matrix}0 &amp; 1\\ 0 &amp;0\end{matrix}\right]~~~~\sigma^-=\left[\begin{matrix}0 &amp; 0\\ 1 &amp;0\end{matrix}\right]~~~~\]</span> <span class="math display">\[\left[\sigma_i, \sigma_j\right]=2i\sigma_k~~~~\left[\sigma_z,\sigma^\pm\right]=\pm2\sigma^\pm\]</span></p><p>对易子运算关系 <span class="math display">\[[\hat A, \hat B] = -[\hat B, \hat A]\]</span> <span class="math display">\[[\hat A, \hat B\hat C] = \hat B[\hat A, \hat C]+[\hat A, \hat B]\hatC~~~~~~~~[\hat A\hat B, \hat C] = \hat A[\hat B, \hat C]+[\hat A, \hat C]\hat B\]</span> 对易子是线性的 <span class="math display">\[[\hat A, \lambda\hat B+\hat C] = \lambda[\hat A, \hat B]+[\hat A, \hatC]\]</span></p><p>重要运算公式（ BCS 展开公式） <span class="math display">\[e^{xA}Be^{-xA}=\sum_{n=0}^\infty\frac{1}{n!}x^nC_n\]</span> 其中 <span class="math display">\[C_0=B~~~~C_n=[A, C_{n-1}]\]</span></p><h3 id="表象变换">表象变换</h3><p>Picture 1 <span class="math display">\[i\hbar\dot{\ket{\psi}}=H\ket{\psi}\]</span> Picture 2 <span class="math display">\[i\hbar\dot{\ket{\psi&#39;}}=H&#39;\ket{\psi&#39;}\]</span> P1 to P2 : <spanclass="math inline">\(\ket{\psi&#39;}=U^\dagger\ket\psi\)</span> <spanclass="math display">\[i\hbar\dot{\ket{\psi&#39;}}=i\hbar\dot{U^\dagger}(U\ket{\psi&#39;})+U^\dagger[H(U\ket\psi&#39;)]=(i\hbar\dot{U^\dagger}U+U^\daggerHU)\ket{\psi&#39;}\\H&#39;=U^\dagger HU+i\hbar\dot{U^\dagger}U\]</span></p><h3 id="sw-变换">SW 变换</h3><p>对于一阶非简并微扰系统 <span class="math display">\[H = H_0 + \lambda H_I\\H\phi=E\phi\]</span> 选取表象变换 <span class="math display">\[\psi=e^{\lambda S}\phi\]</span> 可以得到 <span class="math display">\[\begin{align*}H_S &amp;= e^{\lambda S}He^{-\lambda S}\\&amp;=H+[\lambda S, H]+\frac1{2!}[\lambda S, [\lambda S,H]]+\frac1{3!}[\lambda S, [\lambda S, [\lambda S, H]]]+\cdots\\&amp;=H_0+\lambda(H_I+[S, H_0])+\frac12\lambda^2(2[S, H_I]+[S, [S,H_0]])+O(\lambda^3)\end{align*}\]</span> 选取 <span class="math display">\[H_I+[S, H_0]=0\]</span> 保留到二阶，有 <span class="math display">\[H_S=H_0+\frac12\lambda^2[S, H_I]\]</span> 对于 <span class="math inline">\(H_0\)</span> 的本征态 <spanclass="math inline">\(\ket m, \ket n\)</span> <spanclass="math display">\[\begin{align*}&amp;\bra m H_I\ket n + \bra m [S, H_0]\ket n =0\\&amp;\bra m H_I\ket n + \bra m SH_0-H_0S\ket n =0\\&amp;\bra m H_I\ket n + E_n\bra m S\ket n-E_m\bra mS\ket n =0\\&amp;\bra mS\ket n = \frac{\bra m H_I\ket n}{E_m-E_n}\end{align*}\]</span> 由此，SW 酉变换的生成元算符 S 为 <span class="math display">\[S = \sum_{m, n}\frac{\bra m H_I\ket n}{E_m-E_n}\ket m\bra n\]</span></p><h3 id="jc-model">JC Model</h3><p><span class="math display">\[H=\hbar\omega_r(a^\dagger a+{1\over2})+{\hbar\Omega\over2}\sigma_Z+\hbarg(a\sigma^\dagger+a^\dagger\sigma^-)+H_\kappa+H_\gamma\]</span></p><p>其中，<span class="math inline">\(H_\kappa\)</span>是腔的弛豫，<spanclass="math inline">\(H_\gamma\)</span>是比特的弛豫</p><p>我们考虑旋转表象，对应的变换矩阵满足： <span class="math display">\[\ket{\psi_{rot}}=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}\ket{\psi_{Lab}}\\U^\dagger=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}=e^{iH_0t/\hbar}\]</span> 变换之后的哈密顿量为 <span class="math display">\[\begin{align*}H_{rot}&amp;=U^\dagger HU+i\hbar\dot{U^\dagger}U\\&amp;=U^\dagger(H_0+V)U-H_0\\&amp;=U^\dagger VU\\&amp;=\hbargU^\dagger(a^\dagger\sigma^-+a\sigma^++a^\dagger\sigma^++a\sigma^-)U\end{align*}\]</span> 单独计算四项相互作用项有 <span class="math display">\[\begin{align*}&amp;U^\dagger a^\dagger\sigma^-U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a^\dagger\sigma^-e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a^\dagger\sigma^-e^{i(\omega_r-w_q)t}\\&amp;U^\dagger a\sigma^+U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a\sigma^+e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a\sigma^+e^{-i(\omega_r-w_q)t}\\&amp;U^\dagger a^\dagger\sigma^+U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a^\dagger\sigma^+e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a^\dagger\sigma^+e^{i(\omega_r+w_q)t}\\&amp;U^\dagger a\sigma^-U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a\sigma^-e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a\sigma^-e^{i(\omega_r+w_q)t}\end{align*}\]</span> 故此，哈密顿量可以分成两部分，高频部分和低频部分 <spanclass="math display">\[H_{rot} = \hbarg[(a^\dagger\sigma^-e^{i(\omega_r-w_q)t}+a\sigma^+e^{-i(\omega_r-w_q)t})+(a^\dagger\sigma^+e^{i(\omega_r+w_q)t}+a\sigma^-e^{i(\omega_r+w_q)t})]\]</span> 一般来说 <spanclass="math inline">\(\omega_r\sim\omega_q\)</span>，对比前一项的低频项来说，后面的高频可以直接忽略掉吗，这称之为RWA（旋波近似）。</p><p>回到原来表象下的哈密顿量，可以简化为 <span class="math display">\[H = \hbar\omega_r(a^\daggera+\frac12)+\frac12\hbar\omega_q\sigma_z+\hbarg(a^\dagger\sigma^-+a\sigma^+)\]</span> 考虑到耦合项的形式，只有 <span class="math inline">\(\ket{n,g}\)</span> 和 <span class="math inline">\(\ket{n-1, e}\)</span>耦合在一起，计算哈密顿量作用在非耦合态上的情况有 <spanclass="math display">\[\begin{align*}H\ket{0, g}&amp;=-\frac12\hbar\Delta\ket{0, g}\\H\ket{0, e}&amp;=(\hbar\omega_r+\frac12\hbar\Delta)\ket{0, e}+\hbarg\ket{1, g}\\H\ket{1, g}&amp;=(\hbar\omega_r-\frac12\hbar\Delta)\ket{1, g}+\hbarg\ket{0, e}\\H\ket{n-1, e}&amp;=(n\hbar\omega_r+\frac12\hbar\Delta)\ket{n-1,e}+\hbar\sqrt{n}g\ket{n, g}\\H\ket{n, g}&amp;=(n\hbar\omega_r-\frac12\hbar\Delta)\ket{n, g}+\hbar\sqrt{n}g\ket{n-1, e}\end{align*}\]</span> 其中，<spanclass="math inline">\(\Delta=\omega_q-\omega_r\)</span>表示人工原子和腔之间的失谐，可以发现，除了基态外，其余各态都出现了临近态耦合的情况，也即哈密顿量分块对角。<span class="math display">\[H_n=\left[\begin{matrix}n\hbar\omega_r+\frac12\hbar\Delta &amp;\sqrt{n}\hbar g\\\sqrt{n}\hbar g &amp;n\hbar\omega_r-\frac12\hbar\Delta\end{matrix}\right]\]</span></p><figure><img src="/img/md/image-20221031185742696.png"alt="image-20221031185742696" /><figcaption aria-hidden="true">image-20221031185742696</figcaption></figure><p>可以求解出系统的能级和本征态（在这个系统中这里又可以称为缀饰态）<span class="math display">\[E_0=-\frac12\hbar\Delta\\E_{n, \pm}=n\hbar\omega_r\pm\frac\hbar2\sqrt{4ng^2+\Delta^2}\]</span></p><figure><img src="/img/md/image-20221031185849760.png"alt="image-20221031185849760" /><figcaption aria-hidden="true">image-20221031185849760</figcaption></figure><p><span class="math display">\[\begin{align*}\ket{0}&amp;=\ket{0, g}\\\ket{n, +}&amp;=\cos\theta_n\ket{n, g}+\sin\theta_n\ket{n-1, e}\\\ket{n, -}&amp;=-\sin\theta_n\ket{n, g}+\cos\theta_n\ket{n-1, e}\\\theta_n&amp;=\frac12\arctan{\frac{2\sqrt{n}g}{|{\Delta}|}}\end{align*}\]</span></p><blockquote><p>注意，这里考虑的是 <span class="math inline">\(\Delta&lt;0\)</span>，另一边的情况下，形式有所不同，但最终的结果是自洽的，也因此后续采用SW变换来得到最终结果，更为直接简洁。</p></blockquote><p>考虑色散区（大失谐条件 <spanclass="math inline">\(g\ll|\Delta|\)</span> ） <spanclass="math display">\[\begin{align*}E_{n,\pm}&amp;=n\hbar\omega_r\pm\frac\hbar2|\Delta|\sqrt{1+4n\frac{g^2}{\Delta^2}}\\&amp;=n\hbar\omega_r\pm\frac\hbar2|\Delta|(1+2n\frac{g^2}{\Delta^2})\\&amp;=n\hbar(\omega_r\pm\frac{g^2}{|\Delta|})\mp\frac\hbar2|\Delta|\\\end{align*}\]</span></p><p><span class="math display">\[\ket{n, +}\simeq\ket{n, g}+\sqrt{n}\frac{g}{|\Delta|}\ket{n-1, e}\\\ket{n, -}\simeq-\sqrt{n}\frac{g}{|\Delta|}\ket{n, g}+\ket{n-1, e}\]</span></p><p>在低能级的情况下，<spanclass="math inline">\(\frac{g}{|\Delta|}\ll1\)</span>的近似条件是合理的，但是在 n比较大的情况下，小量近似将不再成立，更强的近似条件其实是 <spanclass="math inline">\(\frac{2\sqrt{n}g}{|\Delta|}\ll1\)</span></p><p>如果我们考虑 <span class="math display">\[\ket{n, +}\simeq\ket{n, g}\\\ket{n, -}\simeq\ket{n-1, e}\]</span> 那么哈密顿量可以近似写为 <span class="math display">\[\begin{align*}H &amp;= E_0\ket{0, g}\bra{0, g}+\sum_{n=1}^{\infty}(E_{n, +}\ket{n,+}\bra{n, +}+E_{n, -}\ket{n, -}\bra{n, -})\\&amp;=-\frac12\hbar\Delta\ket{0, g}\bra{0,g}+\sum_{n=0}^{\infty}n\hbar\omega_r\ket n\branI_q+\sum_{n=0}^{\infty}n\hbar\frac{g^2}{\Delta}\ket n\bra n\sigma_z\\&amp;~~~~~+\frac12\hbar\Delta\ket{0, g}\bra{0,g}+\sum_{n=0}^{\infty}\hbar(\omega_r+\frac{g^2}{\Delta})\ket n\bran~\ket e\bra e+\frac12\hbar\Delta\sum_{n=0}^{\infty}\ket n\bran\sigma_z\\&amp;=\hbar\omega_ra^\dagger a+\hbar\frac{g^2}{\Delta}a^\daggera\sigma_z+\frac12\hbar\Delta\sigma_z+\hbar(\omega_r+\frac{g^2}\Delta)\kete\bra e\end{align*}\]</span> 考虑到 <span class="math display">\[\hbar(\omega_r+\frac{g^2}\Delta)\ket e\brae=\frac\hbar2(\omega_r+\frac{g^2}\Delta)\sigma_z+\frac\hbar2(\omega_r+\frac{g^2}\Delta)I_q\]</span> 由此哈密顿量可以简化为 <span class="math display">\[\begin{align*}H &amp;=\hbar\omega_ra^\dagger a+\hbar\frac{g^2}{\Delta}a^\daggera\sigma_z+\frac\hbar2(\Delta+\omega_r+\frac{g^2}\Delta)\sigma_z\\&amp;=\hbar(\omega_r+\frac{g^2}{\Delta}\sigma_z)a^\daggera+\frac\hbar2(\omega_q+\frac{g^2}\Delta)\sigma_z\end{align*}\]</span></p><h3 id="jc-model-的-sw-变换">JC Model 的 SW 变换</h3><p><span class="math display">\[H = \hbar\omega_r(a^\daggera+\frac12)+\frac12\hbar\omega_q\sigma_z+\hbarg(a^\dagger\sigma^-+a\sigma^+)\]</span></p><p>先考虑相互作用绘景的表象变换 <span class="math display">\[U^\dagger=e^{i\omega_ra^\dagger at+i\omega_r\sigma_zt}\]</span> 将 JC 哈密顿量分解为两部分 <span class="math display">\[H_0 = \hbar\omega_r(a^\dagger a+\frac12)+\frac12\hbar\omega_r\sigma_z\\H&#39;=\frac12\hbar\Delta\sigma_z+\hbar g(a^\dagger\sigma^-+a\sigma^+)\]</span> 变换得到 <span class="math display">\[U^\dagger HU=H&#39;\]</span> 选取生成元算符 S <span class="math display">\[S = \sum_{m, n}\frac{\bra m H_I\ket n}{E_m-E_n}\ket m\bra n\\其中~m=e, g; n=e, g\\H_I=\hbar g(a^\dagger\sigma^-+a\sigma^+)\\H&#39;=H_0&#39;+H_I\]</span> 可以得到 <span class="math display">\[\begin{align*}S &amp;= g\frac{\bra e a^\dagger\sigma^-+a\sigma^+\ket g}{\Delta}\kete\bra g+g\frac{\bra g a^\dagger\sigma^-+a\sigma^+\ket e}{-\Delta}\ketg\bra e\\&amp;=\frac{g}{\Delta}(a\ket e\bra g-a^\dagger\ket g\bra e)\\&amp;=\frac{g}{\Delta}(a\sigma^+-a^\dagger\sigma^-)\end{align*}\]</span> 根据 SW 变换有 <span class="math display">\[H&#39;=\frac12\hbar\Delta\sigma_z+\frac12[S, H_I]\]</span> 其中 <span class="math display">\[\begin{align*}[S, H_I]&amp;=[\frac g\Delta(a\sigma^+-a^\dagger\sigma^-), \hbarg(a\sigma^++a^\dagger\sigma^-)]\\&amp;=2\hbar\frac{g^2}{\Delta}[a\sigma^+, a^\dagger\sigma^-]\\&amp;=2\hbar\frac{g^2}{\Delta}(a^\daggera\sigma_z+\frac12+\frac12\sigma_z)\end{align*}\]</span> 最终有 <span class="math display">\[H&#39; =\frac12\hbar(\Delta+\hbar\frac{g^2}{\Delta})\sigma_z+\hbar\frac{g^2}{\Delta}a^\daggera\sigma_z+\hbar\frac{g^2}{\Delta}\]</span> 回到原表象可以得到 <span class="math display">\[H = \hbar(\omega_r+\frac{g^2}{\Delta}\sigma_z)(a^\daggera+\frac12)+\frac\hbar2(\omega_q+\frac{g^2}{\Delta})\sigma_z\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qubit</tag>
      
      <tag>超导量子计算</tag>
      
      <tag>导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 远程连接传输文件</title>
    <link href="/2023/05/17/Windows%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"/>
    <url>/2023/05/17/Windows%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="windows-远程连接传输文件">Windows 远程连接传输文件</h1><p>我们通过Windows远程连接服务器来跑ansys仿真时，需要用到文件传输功能，将本地的工程项目发送到服务器，进而进行计算，此时可以通过远程连接的网络存储连接功能，将本地的磁盘映射为远程服务器的一个网络磁盘。首先打开远程连接的窗口 <img src="/img/md/20220323145737.png" /> 点击<code>显示选项</code> ，出现远程连接的设置窗口，选择<code>本地资源</code> 选项卡 <img src="/img/md/20220323145937.png" />点击 <code>详细信息</code>，勾选驱动器栏目下，你希望在远程服务器来进行访问的本地磁盘，例如这里是C盘（因为我的电脑只有一个盘）<img src="/img/md/20220323150135.png" /> 然后点击 <code>确定</code>，即可保存设置，随后连接远程服务器，即可在文件资源管理器中看见一个重定向的网络磁盘<img src="/img/md/20220323150401.png" />即可正常在远程服务器访问本地电脑上的文件，同时也可正常复制文件到服务器的磁盘中，来完成数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>远程桌面</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle Application插件自定义打包</title>
    <link href="/2023/05/17/Gradle%20Application%E6%8F%92%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85/"/>
    <url>/2023/05/17/Gradle%20Application%E6%8F%92%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="gradle-application插件自定义打包">GradleApplication插件自定义打包</h1><h2 id="目标需求">目标需求</h2><ol type="1"><li>启动脚本中添加指定内容</li><li>zip中添加指定文件</li></ol><h2 id="实现">实现</h2><h3 id="启动脚本中添加指定内容">启动脚本中添加指定内容</h3><p>在PTAssist项目的开发中，我们基于kotlin语言开发javafx程序，并通过gradle来进行依赖管理，最终我们使用Application插件的distZip进行项目打包，这会自动生成一个目录结构如下所示的zip文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">xxx.zip<br>    |- xxx<br>        |- bin<br>            |- xxx<br>            |- xxx.bat<br>        |- lib<br>            |- aaa.jar<br>            ...<br>            |- nnn.jar<br></code></pre></td></tr></table></figure><p>其中 <code>bin</code> 目录下是对应的启动脚本， <code>lib</code>目录下是程序jar包</p><p>插件默认提供的启动脚本中没有pause命令，所以如果程序出现什么无法启动的错误，就会出现cmd一闪而过的问题，很难排查错误，也不利于用户使用</p><p>于是我们需要在打包的过程中，往启动脚本中注入一行pause</p><p>我们发现，可以通过修改application插件提供的startScripts的Task来手动注入一行pause</p><p>具体代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Groovy">tasks.startScripts &#123;<br>    doLast &#123;<br>        <span class="hljs-keyword">def</span> windowsScriptFile = getWindowsScript()<br>        windowsScriptFile.text = windowsScriptFile.text.replace(<span class="hljs-string">&quot;\n:end&quot;</span>, <span class="hljs-string">&quot;pause\n\n:end&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="zip中添加指定文件">zip中添加指定文件</h3><p>我们的项目需要在打包时加入一个README.md作为用户的使用说明文件</p><p>我们这里采用的是修改distribution插件的配置，因为application插件会自动应用此插件，所以其实可以通过distribution插件的配置来控制application插件的打包内容</p><p>由于默认使用的是 <code>Groovy</code> 的gradle配置文件，所以可以通过<code>Groovy</code>脚本语言提供的功能来自定义的添加需要被打包进入zip的文件或者文件夹</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Groovy"><span class="hljs-comment">// 打包时加入README.md</span><br><br>distributions &#123;<br>    main &#123;<br>        contents &#123;<br>            from parent.file(<span class="hljs-string">&#x27;README_Client.md&#x27;</span>)<br>            parent.file(<span class="hljs-string">&quot;assets&quot;</span>).listFiles().each &#123;<br>                from(it) &#123;<br>                    into <span class="hljs-string">&quot;assets&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过 <code>parent</code> 获取到了模块对应的项目根目录，然后<code>assets</code>存放的是readme文件所需的图片，所以也需要一并打包进去。</p><p>做完之后，个人觉得，如果最开始采用的是基于kotlin语言的<code>bulid.gradle</code>，那么写这些配置可能会简单一些，而且应该会有比较好的补全。（idea默认不会补全build.gradle里面的groovy的语法，有点蛋疼）</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/17/hello-world/"/>
    <url>/2023/05/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
