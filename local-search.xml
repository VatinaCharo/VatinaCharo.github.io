<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>VSCodeJupyter的交互式绘图配置</title>
    <link href="/2023/06/16/VSCodeJupyter%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BB%98%E5%9B%BE%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/06/16/VSCodeJupyter%E7%9A%84%E4%BA%A4%E4%BA%92%E5%BC%8F%E7%BB%98%E5%9B%BE%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1id="vscodejupyter的交互式绘图配置">VSCodeJupyter的交互式绘图配置</h1><h2 id="安装支持库">安装支持库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install ipympl<br></code></pre></td></tr></table></figure><p>安装完成后需要重启Jupyter服务</p><h2 id="vscode使用">VSCode使用</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib widget <span class="hljs-comment"># 切换 matplotlib 的绘图后端为 ipympl</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><h2 id="demo">Demo</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib widget<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">time = [<span class="hljs-number">0</span>, <span class="hljs-number">180</span>, <span class="hljs-number">240</span>, <span class="hljs-number">360</span>, <span class="hljs-number">390</span>]<br>plt.figure()<br>plt.plot(time,[<span class="hljs-number">0</span>, <span class="hljs-number">15</span>, <span class="hljs-number">15</span>, <span class="hljs-number">23</span>, <span class="hljs-number">23</span>])<br>plt.xticks([<span class="hljs-number">180</span>, <span class="hljs-number">240</span>, <span class="hljs-number">360</span>, <span class="hljs-number">390</span>], [<span class="hljs-string">&quot;3:00&quot;</span>,<span class="hljs-string">&quot;4:00&quot;</span>,<span class="hljs-string">&quot;6:00&quot;</span>,<span class="hljs-string">&quot;6:30&quot;</span>])<br>plt.title(<span class="hljs-string">&quot;Before Deposition&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Power&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/img/md/image-20230616183028835.png"alt="image-20230616183028835" /><figcaption aria-hidden="true">image-20230616183028835</figcaption></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">time = [<span class="hljs-number">0</span>, <span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>]<br>plt.figure()<br>plt.plot(time,[<span class="hljs-number">23</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span>])<br>plt.xticks([<span class="hljs-number">30</span>, <span class="hljs-number">50</span>, <span class="hljs-number">60</span>], [<span class="hljs-string">&quot;0:30&quot;</span>,<span class="hljs-string">&quot;0:50&quot;</span>,<span class="hljs-string">&quot;1:00&quot;</span>])<br>plt.title(<span class="hljs-string">&quot;After Deposition&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;Power&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;Time&quot;</span>)<br></code></pre></td></tr></table></figure><figure><img src="/img/md/image-20230616183059631.png"alt="image-20230616183059631" /><figcaption aria-hidden="true">image-20230616183059631</figcaption></figure><h2 id="注意事项">注意事项</h2><p>每次绘图时需要多加一行代码，用于创建一个新的画布</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure()<br></code></pre></td></tr></table></figure><p>如果不新建画布，会导致不同cell之间的plt绘图共用同一张画布</p><p><em>也可以使用ax的方式绘图</em></p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
      <tag>Jupyter</tag>
      
      <tag>Matplotlib</tag>
      
      <tag>ipympl</tag>
      
      <tag>VSCode</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超导量子计算常用物理常数</title>
    <link href="/2023/05/21/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E7%89%A9%E7%90%86%E5%B8%B8%E6%95%B0/"/>
    <url>/2023/05/21/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%B8%B8%E7%94%A8%E7%89%A9%E7%90%86%E5%B8%B8%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="超导量子计算常用物理常数">超导量子计算常用物理常数</h1><table><thead><tr class="header"><th>常数</th><th>符号</th><th>数值</th></tr></thead><tbody><tr class="odd"><td>约化普朗克常数</td><td><span class="math inline">\(\hbar\)</span></td><td><span class="math inline">\(1.055\times10^{-34}J\cdots\)</span></td></tr><tr class="even"><td>电子电荷</td><td><span class="math inline">\(e\)</span></td><td><span class="math inline">\(1.602\times10^{-19}C\)</span></td></tr><tr class="odd"><td>磁通量子</td><td><span class="math inline">\(\Phi_0\)</span></td><td><span class="math inline">\(2.068\times10^{-15}Wb\)</span></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qubit</tag>
      
      <tag>超导量子计算</tag>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>黑塔情诗</title>
    <link href="/2023/05/21/%E9%BB%91%E5%A1%94%E6%83%85%E8%AF%97/"/>
    <url>/2023/05/21/%E9%BB%91%E5%A1%94%E6%83%85%E8%AF%97/</url>
    
    <content type="html"><![CDATA[<p>当爱情踏上旅途 当时间燃尽壁炉 当一条去咖啡馆的路 要从婴孩走向坟墓当一次恋人的期待 要用一生去满足 你当出发？ 还是止步 ———— <ahref="https://www.bilibili.com/video/BV1Mv4y1J7xU">【基德】用相对论玩星穹铁道by 吟游诗人·基德</a></p>]]></content>
    
    
    <categories>
      
      <category>诗与歌与远方</category>
      
    </categories>
    
    
    <tags>
      
      <tag>诗</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>超导量子计算导论</title>
    <link href="/2023/05/17/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA/"/>
    <url>/2023/05/17/%E8%B6%85%E5%AF%BC%E9%87%8F%E5%AD%90%E8%AE%A1%E7%AE%97%E5%AF%BC%E8%AE%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="量子计算简介">量子计算简介</h1><h3 id="bloch球">Bloch球</h3><p>量子比特的纯态可以用Bloch球表示</p><figure><img src="/img/md/20220214224730.png" alt="20220214224730" /><figcaption aria-hidden="true">20220214224730</figcaption></figure><p><span class="math display">\[\ket{\psi}=\cos({\theta\over2})\ket{0}+e^{i\phi}\sin({\theta\over2})\ket{1}\]</span> 注意这里的<spanclass="math inline">\(\theta\)</span>会和布居数（占据数）联系，<spanclass="math inline">\(\phi\)</span>则是相对相位（这很显然）</p><h3 id="旋转操作算符">旋转操作算符</h3><p>考虑对一个量子态在Bloch球上进行旋转操作，旋转轴为<spanclass="math inline">\(\vec{n}\)</span>，旋转角度为<spanclass="math inline">\(\alpha\)</span> 记为 <span class="math display">\[\hat{U}=\hat{U}(\vec{n},\alpha)=e^{-i\alpha{\vec{n}\cdot\hat{\vec{S}}\over\hbar}}\]</span> 对于Bloch球表示的体系，<spanclass="math inline">\(\hat{\vec{S}}={\hbar\over2}\hat{\vec{\sigma}}\)</span>所以我们可以得到旋转操作算符 <span class="math display">\[\hat{U}(\vec{n},\alpha)=e^{-i{\alpha\over2}\vec{n}\cdot\hat{\vec{\sigma}}}=\cos({\alpha\over2})-i\vec{n}\cdot\hat{\vec{\sigma}}\sin({\alpha\over2})\]</span> 这里已经利用了扩展的欧拉公式，其中<spanclass="math inline">\((\vec{n}\cdot\hat{\vec{\sigma}})^2=\hat{I}\)</span>证明如下 <span class="math display">\[\hat{q}^2=\hat{I}\]</span></p><p><span class="math display">\[e^{i\theta\hat{q}}=\sum_{k=0}^\infty[{(-1)^k\theta^{2k}\over(2k)!}+i\hat{q}{(-1)^k\theta^{2k+1}\over(2k+1)!}]=\cos\theta+i\hat{q}\sin\theta\]</span></p><h2 id="lc振荡电路及其量子化">LC振荡电路及其量子化</h2><figure><img src="/img/md/lc.gif" alt="lc" /><figcaption aria-hidden="true">lc</figcaption></figure><figure><img src="/img/md/20220512224156.png" alt="20220512224156" /><figcaption aria-hidden="true">20220512224156</figcaption></figure><p>系统的哈密顿量为 <span class="math display">\[H = {Q^2\over2C}+{\Phi^2\over2L}\]</span> 其中<spanclass="math inline">\(Q\)</span>是电容的电荷量，<spanclass="math inline">\(\Phi\)</span>是电感的磁通量 使用基本电荷<spanclass="math inline">\(e\)</span>和磁通量子<spanclass="math inline">\(\Phi_0={h\over2e}\)</span>改写，<spanclass="math inline">\(n={Q\over2e}, ~\phi={2\pi\Phi\over\Phi_0}={4\pie\Phi\over h}\)</span>可以有 <span class="math display">\[H = 4{e^2\over2C}n^2+{(\Phi_0/2\pi)^2\over2L}\phi^2\]</span> 可以进一步得到 <span class="math display">\[E_C = {e^2\over2C}~~~~E_L={(\Phi_0/2\pi)^2\over2L}\]</span>分别代表一个电荷所带来的电容器上的能量，以及一个磁通量子所带来的电感上的能量量子化后有 <span class="math display">\[H=4E_C\hat{n}^2+E_L\hat{\phi}^2\]</span></p><p><span class="math display">\[[\hat \phi, \hat n]=i\]</span></p><h2 id="约瑟夫森结">约瑟夫森结</h2><figure><img src="/img/md/20220215005311.png" alt="20220215005311" /><figcaption aria-hidden="true">20220215005311</figcaption></figure><p>约瑟夫森结由两层超导体夹着一层绝缘体组成，其行为由约瑟夫森方程决定：<span class="math display">\[V(t)={\mathrm{d}\Phi(t)\over\mathrm{d}t}\]</span></p><p><span class="math display">\[I(t)=I_s\sin(2\pi{\Phi(t)\over\Phi_0})\]</span></p><p>其中，<spanclass="math inline">\(\Phi\)</span>是以磁通量子为单位来描述的两超导体之间的序参量位相差</p><h3 id="直流伏安特性">直流伏安特性</h3><p>当偏置电流从0开始增大，结两端的电压一直为0，直到电流大于临界电流<spanclass="math inline">\(I_s\)</span>，此时结两端突然出现电压<spanclass="math inline">\(V=2\Delta/e\)</span>，其中<spanclass="math inline">\(\Delta\)</span>是材料的超导能隙；继续增大电流，系统表现出正常电阻状态；减小偏置电压至<spanclass="math inline">\(2\Delta/e\)</span>，结两端电流减小至<spanclass="math inline">\(I_s\)</span>；电压继续减小，电流一直保持在<spanclass="math inline">\(I_s\)</span>，直到电压减小为0。</p><h3 id="等效电感">等效电感</h3><p><span class="math display">\[L = {V\over\dot I}={\Phi_0\over2\pi I_s\cos(2\pi{\Phi(t)\over\Phi_0})}\]</span></p><p>可以看到，对于一个约瑟夫森结，可以等效的看作有一个非线性的电感存在。其包含的能量可以计算为 <span class="math display">\[E = \int IV\mathrm dt ={I_s\Phi_0\over2\pi}\int\sin(2\pi{\Phi(t)\over\Phi_0}){\mathrm{d}\Phi(t)\over\mathrm{d}t}\mathrmdt=-{I_s\Phi_0\over2\pi}\cos(2\pi{\Phi(t)\over\Phi_0})\]</span> 有 <span class="math display">\[E_J = {I_s\Phi_0\over2\pi}\]</span>表示一个磁通量子在约瑟夫森结中所带来的能量，考虑到和电荷能的对偶关系，可以认为是一对电子（一个库伯对）穿越约瑟夫森结时所需的能量考虑仅含一个约瑟夫森结的闭合回路，由于结自身所带的电容<spanclass="math inline">\(C\)</span>，这构成了一个LC振荡电路，我们依据之前的关系，可以得到<span class="math display">\[H =4E_C\hat{n}^2-E_J\cos(2\pi{\hat\Phi(t)\over\Phi_0})=4E_C\hat{n}^2-E_J\cos\hat\phi\]</span></p><h3 id="dc-squid">DC-SQUID</h3><figure><img src="/img/md/20220506170057.png" alt="20220506170057" /><figcaption aria-hidden="true">20220506170057</figcaption></figure><p>依照约瑟夫森结方程 <span class="math display">\[I=I_a\sin\phi_a+I_b\sin\phi_b\]</span> 考虑a结和b结相同，则有 <span class="math display">\[\begin{align*}I &amp;= I_a(\sin\phi_a+\sin\phi_b)\\&amp;= 2I_a\cos({\phi_a-\phi_b\over2})\sin({\phi_a+\phi_b\over2})\\&amp;= I_c\sin(\phi)\end{align*}\\\]</span> 考虑环形回路中有偏置磁通量<spanclass="math inline">\(\Phi_c\)</span> 由<spanclass="math inline">\(\hbar\nabla\psi=2e\vec{A}\)</span>有： <spanclass="math display">\[\begin{align*}\int_{SQUID}\hbar\nabla\phi\cdot\mathrm d\vec l = \int_{SQUID}2e\vecA\cdot\mathrm d\vec l\\\Longrightarrow\hbar(\phi_a-\phi_b)=2e\cdot\Phi_c\end{align*}\]</span> 由此我们得到： <span class="math display">\[I_c=2I_a\cos({2e\cdot\Phi_c\over2\hbar})=2I_a\cos(\pi\cdot{2e\overh}\cdot\Phi_c)=2I_a\cos(\pi{\Phi_c\over\Phi_0})\]</span> 最终，DC-SQUID和一个电容形成的超导回路，满足 <spanclass="math display">\[\begin{align*}H=4E_c\hat n^2-2E_{J, c}\cos\hat \phi\\E_{J, c}=E_J\cos(\pi\cdot{\Phi_c\over\Phi_0})\end{align*}\]</span> 所以，如果我们调控偏置磁通量<spanclass="math inline">\(\Phi_c\)</span>，就能够人为的调控等效约瑟夫森结的电流<spanclass="math inline">\(I_c\)</span>，也就能调控<spanclass="math inline">\(E_{J, c}\)</span>，进而可以调控比特频率</p><h2 id="qubit-architecture">Qubit Architecture</h2><h3 id="cpbcooper-pair-box">CPB(Cooper Pair Box)</h3><figure><img src="/img/md/cpb.png" alt="cpb" /><figcaption aria-hidden="true">cpb</figcaption></figure><figure><img src="/img/md/20220506165827.png" alt="20220506165827" /><figcaption aria-hidden="true">20220506165827</figcaption></figure><p>系统的广义动能项为 <span class="math display">\[T={C_g\over2}\dot\phi_J^2+{C_J\over2}\dot\phi_J^2={C_\Sigma\over2}\dot\phi_J^2\]</span> 其中<spanclass="math inline">\(C_\Sigma=C_g+C_J\)</span>表征系统的总体电容值，代表了CPB的电荷储能能力以及系统量子态对电荷的敏感程度CPB的广义势能项包括两个部分，约瑟夫森结的等效电感储能以及外部给予的电势能<span class="math display">\[U = -E_J\cos({2\pi\over\Phi_0}\phi_J)-V_gC_g\dot\phi_J\]</span> 可以得到CPB的哈密顿量为 <span class="math display">\[H = {(Q_J-C_gV_g)^2\over2C_\Sigma}-E_J\cos({2\pi\over\Phi_0}\phi_J)\]</span></p><h3 id="capacitive-shunted-cpb">Capacitive-shunted CPB</h3><p>出于压制电荷噪声的考虑，可以提高CPB中的<spanclass="math inline">\(C_\Sigma\)</span>，因此加上一个旁接在结上的大电容<spanclass="math inline">\(C_{sh}\)</span>。</p><p>满足条件<span class="math inline">\(C_{sh}\gg C_J\)</span></p><h2 id="cavity-qed">Cavity QED</h2><h3 id="重要的数学前提">重要的数学前提</h3><p><span class="math display">\[[a^\dagger, a]=-1\]</span></p><p><span class="math display">\[\sigma_z=\left[\begin{matrix}1 &amp; 0\\ 0 &amp;-1\end{matrix}\right]~~~~\sigma_x=\left[\begin{matrix}0 &amp; 1\\ 1 &amp;0\end{matrix}\right]~~~~\sigma_y=\left[\begin{matrix}0 &amp; - i\\ i &amp; 0\end{matrix}\right]\]</span></p><p><span class="math display">\[\sigma^+=\left[\begin{matrix}0 &amp; 1\\ 0 &amp;0\end{matrix}\right]~~~~\sigma^-=\left[\begin{matrix}0 &amp; 0\\ 1 &amp;0\end{matrix}\right]~~~~\]</span> <span class="math display">\[\left[\sigma_i, \sigma_j\right]=2i\sigma_k~~~~\left[\sigma_z,\sigma^\pm\right]=\pm2\sigma^\pm\]</span></p><p>对易子运算关系 <span class="math display">\[[\hat A, \hat B] = -[\hat B, \hat A]\]</span> <span class="math display">\[[\hat A, \hat B\hat C] = \hat B[\hat A, \hat C]+[\hat A, \hat B]\hatC~~~~~~~~[\hat A\hat B, \hat C] = \hat A[\hat B, \hat C]+[\hat A, \hat C]\hat B\]</span> 对易子是线性的 <span class="math display">\[[\hat A, \lambda\hat B+\hat C] = \lambda[\hat A, \hat B]+[\hat A, \hatC]\]</span></p><p>重要运算公式（ BCS 展开公式） <span class="math display">\[e^{xA}Be^{-xA}=\sum_{n=0}^\infty\frac{1}{n!}x^nC_n\]</span> 其中 <span class="math display">\[C_0=B~~~~C_n=[A, C_{n-1}]\]</span></p><h3 id="表象变换">表象变换</h3><p>Picture 1 <span class="math display">\[i\hbar\dot{\ket{\psi}}=H\ket{\psi}\]</span> Picture 2 <span class="math display">\[i\hbar\dot{\ket{\psi&#39;}}=H&#39;\ket{\psi&#39;}\]</span> P1 to P2 : <spanclass="math inline">\(\ket{\psi&#39;}=U^\dagger\ket\psi\)</span> <spanclass="math display">\[i\hbar\dot{\ket{\psi&#39;}}=i\hbar\dot{U^\dagger}(U\ket{\psi&#39;})+U^\dagger[H(U\ket\psi&#39;)]=(i\hbar\dot{U^\dagger}U+U^\daggerHU)\ket{\psi&#39;}\\H&#39;=U^\dagger HU+i\hbar\dot{U^\dagger}U\]</span></p><h3 id="sw-变换">SW 变换</h3><p>对于一阶非简并微扰系统 <span class="math display">\[H = H_0 + \lambda H_I\\H\phi=E\phi\]</span> 选取表象变换 <span class="math display">\[\psi=e^{\lambda S}\phi\]</span> 可以得到 <span class="math display">\[\begin{align*}H_S &amp;= e^{\lambda S}He^{-\lambda S}\\&amp;=H+[\lambda S, H]+\frac1{2!}[\lambda S, [\lambda S,H]]+\frac1{3!}[\lambda S, [\lambda S, [\lambda S, H]]]+\cdots\\&amp;=H_0+\lambda(H_I+[S, H_0])+\frac12\lambda^2(2[S, H_I]+[S, [S,H_0]])+O(\lambda^3)\end{align*}\]</span> 选取 <span class="math display">\[H_I+[S, H_0]=0\]</span> 保留到二阶，有 <span class="math display">\[H_S=H_0+\frac12\lambda^2[S, H_I]\]</span> 对于 <span class="math inline">\(H_0\)</span> 的本征态 <spanclass="math inline">\(\ket m, \ket n\)</span> <spanclass="math display">\[\begin{align*}&amp;\bra m H_I\ket n + \bra m [S, H_0]\ket n =0\\&amp;\bra m H_I\ket n + \bra m SH_0-H_0S\ket n =0\\&amp;\bra m H_I\ket n + E_n\bra m S\ket n-E_m\bra mS\ket n =0\\&amp;\bra mS\ket n = \frac{\bra m H_I\ket n}{E_m-E_n}\end{align*}\]</span> 由此，SW 酉变换的生成元算符 S 为 <span class="math display">\[S = \sum_{m, n}\frac{\bra m H_I\ket n}{E_m-E_n}\ket m\bra n\]</span></p><h3 id="jc-model">JC Model</h3><p><span class="math display">\[H=\hbar\omega_r(a^\dagger a+{1\over2})+{\hbar\Omega\over2}\sigma_Z+\hbarg(a\sigma^\dagger+a^\dagger\sigma^-)+H_\kappa+H_\gamma\]</span></p><p>其中，<span class="math inline">\(H_\kappa\)</span>是腔的弛豫，<spanclass="math inline">\(H_\gamma\)</span>是比特的弛豫</p><p>我们考虑旋转表象，对应的变换矩阵满足： <span class="math display">\[\ket{\psi_{rot}}=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}\ket{\psi_{Lab}}\\U^\dagger=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}=e^{iH_0t/\hbar}\]</span> 变换之后的哈密顿量为 <span class="math display">\[\begin{align*}H_{rot}&amp;=U^\dagger HU+i\hbar\dot{U^\dagger}U\\&amp;=U^\dagger(H_0+V)U-H_0\\&amp;=U^\dagger VU\\&amp;=\hbargU^\dagger(a^\dagger\sigma^-+a\sigma^++a^\dagger\sigma^++a\sigma^-)U\end{align*}\]</span> 单独计算四项相互作用项有 <span class="math display">\[\begin{align*}&amp;U^\dagger a^\dagger\sigma^-U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a^\dagger\sigma^-e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a^\dagger\sigma^-e^{i(\omega_r-w_q)t}\\&amp;U^\dagger a\sigma^+U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a\sigma^+e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a\sigma^+e^{-i(\omega_r-w_q)t}\\&amp;U^\dagger a^\dagger\sigma^+U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a^\dagger\sigma^+e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a^\dagger\sigma^+e^{i(\omega_r+w_q)t}\\&amp;U^\dagger a\sigma^-U=e^{ia^\daggera\omega_rt+i\frac{\sigma_z}{2}\omega_qt}a\sigma^-e^{-ia^\daggera\omega_rt-i\frac{\sigma_z}{2}\omega_qt}=a\sigma^-e^{i(\omega_r+w_q)t}\end{align*}\]</span> 故此，哈密顿量可以分成两部分，高频部分和低频部分 <spanclass="math display">\[H_{rot} = \hbarg[(a^\dagger\sigma^-e^{i(\omega_r-w_q)t}+a\sigma^+e^{-i(\omega_r-w_q)t})+(a^\dagger\sigma^+e^{i(\omega_r+w_q)t}+a\sigma^-e^{i(\omega_r+w_q)t})]\]</span> 一般来说 <spanclass="math inline">\(\omega_r\sim\omega_q\)</span>，对比前一项的低频项来说，后面的高频可以直接忽略掉吗，这称之为RWA（旋波近似）。</p><p>回到原来表象下的哈密顿量，可以简化为 <span class="math display">\[H = \hbar\omega_r(a^\daggera+\frac12)+\frac12\hbar\omega_q\sigma_z+\hbarg(a^\dagger\sigma^-+a\sigma^+)\]</span> 考虑到耦合项的形式，只有 <span class="math inline">\(\ket{n,g}\)</span> 和 <span class="math inline">\(\ket{n-1, e}\)</span>耦合在一起，计算哈密顿量作用在非耦合态上的情况有 <spanclass="math display">\[\begin{align*}H\ket{0, g}&amp;=-\frac12\hbar\Delta\ket{0, g}\\H\ket{0, e}&amp;=(\hbar\omega_r+\frac12\hbar\Delta)\ket{0, e}+\hbarg\ket{1, g}\\H\ket{1, g}&amp;=(\hbar\omega_r-\frac12\hbar\Delta)\ket{1, g}+\hbarg\ket{0, e}\\H\ket{n-1, e}&amp;=(n\hbar\omega_r+\frac12\hbar\Delta)\ket{n-1,e}+\hbar\sqrt{n}g\ket{n, g}\\H\ket{n, g}&amp;=(n\hbar\omega_r-\frac12\hbar\Delta)\ket{n, g}+\hbar\sqrt{n}g\ket{n-1, e}\end{align*}\]</span> 其中，<spanclass="math inline">\(\Delta=\omega_q-\omega_r\)</span>表示人工原子和腔之间的失谐，可以发现，除了基态外，其余各态都出现了临近态耦合的情况，也即哈密顿量分块对角。<span class="math display">\[H_n=\left[\begin{matrix}n\hbar\omega_r+\frac12\hbar\Delta &amp;\sqrt{n}\hbar g\\\sqrt{n}\hbar g &amp;n\hbar\omega_r-\frac12\hbar\Delta\end{matrix}\right]\]</span></p><figure><img src="/img/md/image-20221031185742696.png"alt="image-20221031185742696" /><figcaption aria-hidden="true">image-20221031185742696</figcaption></figure><p>可以求解出系统的能级和本征态（在这个系统中这里又可以称为缀饰态）<span class="math display">\[E_0=-\frac12\hbar\Delta\\E_{n, \pm}=n\hbar\omega_r\pm\frac\hbar2\sqrt{4ng^2+\Delta^2}\]</span></p><figure><img src="/img/md/image-20221031185849760.png"alt="image-20221031185849760" /><figcaption aria-hidden="true">image-20221031185849760</figcaption></figure><p><span class="math display">\[\begin{align*}\ket{0}&amp;=\ket{0, g}\\\ket{n, +}&amp;=\cos\theta_n\ket{n, g}+\sin\theta_n\ket{n-1, e}\\\ket{n, -}&amp;=-\sin\theta_n\ket{n, g}+\cos\theta_n\ket{n-1, e}\\\theta_n&amp;=\frac12\arctan{\frac{2\sqrt{n}g}{|{\Delta}|}}\end{align*}\]</span></p><blockquote><p>注意，这里考虑的是 <span class="math inline">\(\Delta&lt;0\)</span>，另一边的情况下，形式有所不同，但最终的结果是自洽的，也因此后续采用SW变换来得到最终结果，更为直接简洁。</p></blockquote><p>考虑色散区（大失谐条件 <spanclass="math inline">\(g\ll|\Delta|\)</span> ） <spanclass="math display">\[\begin{align*}E_{n,\pm}&amp;=n\hbar\omega_r\pm\frac\hbar2|\Delta|\sqrt{1+4n\frac{g^2}{\Delta^2}}\\&amp;=n\hbar\omega_r\pm\frac\hbar2|\Delta|(1+2n\frac{g^2}{\Delta^2})\\&amp;=n\hbar(\omega_r\pm\frac{g^2}{|\Delta|})\mp\frac\hbar2|\Delta|\\\end{align*}\]</span></p><p><span class="math display">\[\ket{n, +}\simeq\ket{n, g}+\sqrt{n}\frac{g}{|\Delta|}\ket{n-1, e}\\\ket{n, -}\simeq-\sqrt{n}\frac{g}{|\Delta|}\ket{n, g}+\ket{n-1, e}\]</span></p><p>在低能级的情况下，<spanclass="math inline">\(\frac{g}{|\Delta|}\ll1\)</span>的近似条件是合理的，但是在 n比较大的情况下，小量近似将不再成立，更强的近似条件其实是 <spanclass="math inline">\(\frac{2\sqrt{n}g}{|\Delta|}\ll1\)</span></p><p>如果我们考虑 <span class="math display">\[\ket{n, +}\simeq\ket{n, g}\\\ket{n, -}\simeq\ket{n-1, e}\]</span> 那么哈密顿量可以近似写为 <span class="math display">\[\begin{align*}H &amp;= E_0\ket{0, g}\bra{0, g}+\sum_{n=1}^{\infty}(E_{n, +}\ket{n,+}\bra{n, +}+E_{n, -}\ket{n, -}\bra{n, -})\\&amp;=-\frac12\hbar\Delta\ket{0, g}\bra{0,g}+\sum_{n=0}^{\infty}n\hbar\omega_r\ket n\branI_q+\sum_{n=0}^{\infty}n\hbar\frac{g^2}{\Delta}\ket n\bra n\sigma_z\\&amp;~~~~~+\frac12\hbar\Delta\ket{0, g}\bra{0,g}+\sum_{n=0}^{\infty}\hbar(\omega_r+\frac{g^2}{\Delta})\ket n\bran~\ket e\bra e+\frac12\hbar\Delta\sum_{n=0}^{\infty}\ket n\bran\sigma_z\\&amp;=\hbar\omega_ra^\dagger a+\hbar\frac{g^2}{\Delta}a^\daggera\sigma_z+\frac12\hbar\Delta\sigma_z+\hbar(\omega_r+\frac{g^2}\Delta)\kete\bra e\end{align*}\]</span> 考虑到 <span class="math display">\[\hbar(\omega_r+\frac{g^2}\Delta)\ket e\brae=\frac\hbar2(\omega_r+\frac{g^2}\Delta)\sigma_z+\frac\hbar2(\omega_r+\frac{g^2}\Delta)I_q\]</span> 由此哈密顿量可以简化为 <span class="math display">\[\begin{align*}H &amp;=\hbar\omega_ra^\dagger a+\hbar\frac{g^2}{\Delta}a^\daggera\sigma_z+\frac\hbar2(\Delta+\omega_r+\frac{g^2}\Delta)\sigma_z\\&amp;=\hbar(\omega_r+\frac{g^2}{\Delta}\sigma_z)a^\daggera+\frac\hbar2(\omega_q+\frac{g^2}\Delta)\sigma_z\end{align*}\]</span></p><h3 id="jc-model-的-sw-变换">JC Model 的 SW 变换</h3><p><span class="math display">\[H = \hbar\omega_r(a^\daggera+\frac12)+\frac12\hbar\omega_q\sigma_z+\hbarg(a^\dagger\sigma^-+a\sigma^+)\]</span></p><p>先考虑相互作用绘景的表象变换 <span class="math display">\[U^\dagger=e^{i\omega_ra^\dagger at+i\omega_r\sigma_zt}\]</span> 将 JC 哈密顿量分解为两部分 <span class="math display">\[H_0 = \hbar\omega_r(a^\dagger a+\frac12)+\frac12\hbar\omega_r\sigma_z\\H&#39;=\frac12\hbar\Delta\sigma_z+\hbar g(a^\dagger\sigma^-+a\sigma^+)\]</span> 变换得到 <span class="math display">\[U^\dagger HU=H&#39;\]</span> 选取生成元算符 S <span class="math display">\[S = \sum_{m, n}\frac{\bra m H_I\ket n}{E_m-E_n}\ket m\bra n\\其中~m=e, g; n=e, g\\H_I=\hbar g(a^\dagger\sigma^-+a\sigma^+)\\H&#39;=H_0&#39;+H_I\]</span> 可以得到 <span class="math display">\[\begin{align*}S &amp;= g\frac{\bra e a^\dagger\sigma^-+a\sigma^+\ket g}{\Delta}\kete\bra g+g\frac{\bra g a^\dagger\sigma^-+a\sigma^+\ket e}{-\Delta}\ketg\bra e\\&amp;=\frac{g}{\Delta}(a\ket e\bra g-a^\dagger\ket g\bra e)\\&amp;=\frac{g}{\Delta}(a\sigma^+-a^\dagger\sigma^-)\end{align*}\]</span> 根据 SW 变换有 <span class="math display">\[H&#39;=\frac12\hbar\Delta\sigma_z+\frac12[S, H_I]\]</span> 其中 <span class="math display">\[\begin{align*}[S, H_I]&amp;=[\frac g\Delta(a\sigma^+-a^\dagger\sigma^-), \hbarg(a\sigma^++a^\dagger\sigma^-)]\\&amp;=2\hbar\frac{g^2}{\Delta}[a\sigma^+, a^\dagger\sigma^-]\\&amp;=2\hbar\frac{g^2}{\Delta}(a^\daggera\sigma_z+\frac12+\frac12\sigma_z)\end{align*}\]</span> 最终有 <span class="math display">\[H&#39; =\frac12\hbar(\Delta+\hbar\frac{g^2}{\Delta})\sigma_z+\hbar\frac{g^2}{\Delta}a^\daggera\sigma_z+\hbar\frac{g^2}{\Delta}\]</span> 回到原表象可以得到 <span class="math display">\[H = \hbar(\omega_r+\frac{g^2}{\Delta}\sigma_z)(a^\daggera+\frac12)+\frac\hbar2(\omega_q+\frac{g^2}{\Delta})\sigma_z\]</span></p>]]></content>
    
    
    <categories>
      
      <category>Physics</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Qubit</tag>
      
      <tag>超导量子计算</tag>
      
      <tag>导论</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 远程连接传输文件</title>
    <link href="/2023/05/17/Windows%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/"/>
    <url>/2023/05/17/Windows%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5%E4%BC%A0%E8%BE%93%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="windows-远程连接传输文件">Windows 远程连接传输文件</h1><p>我们通过Windows远程连接服务器来跑ansys仿真时，需要用到文件传输功能，将本地的工程项目发送到服务器，进而进行计算，此时可以通过远程连接的网络存储连接功能，将本地的磁盘映射为远程服务器的一个网络磁盘。首先打开远程连接的窗口 <img src="/img/md/20220323145737.png" /> 点击<code>显示选项</code> ，出现远程连接的设置窗口，选择<code>本地资源</code> 选项卡 <img src="/img/md/20220323145937.png" />点击 <code>详细信息</code>，勾选驱动器栏目下，你希望在远程服务器来进行访问的本地磁盘，例如这里是C盘（因为我的电脑只有一个盘）<img src="/img/md/20220323150135.png" /> 然后点击 <code>确定</code>，即可保存设置，随后连接远程服务器，即可在文件资源管理器中看见一个重定向的网络磁盘<img src="/img/md/20220323150401.png" />即可正常在远程服务器访问本地电脑上的文件，同时也可正常复制文件到服务器的磁盘中，来完成数据传输。</p>]]></content>
    
    
    <categories>
      
      <category>Windows</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Windows</tag>
      
      <tag>远程桌面</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gradle Application插件自定义打包</title>
    <link href="/2023/05/17/Gradle%20Application%E6%8F%92%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85/"/>
    <url>/2023/05/17/Gradle%20Application%E6%8F%92%E4%BB%B6%E8%87%AA%E5%AE%9A%E4%B9%89%E6%89%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h1 id="gradle-application插件自定义打包">GradleApplication插件自定义打包</h1><h2 id="目标需求">目标需求</h2><ol type="1"><li>启动脚本中添加指定内容</li><li>zip中添加指定文件</li></ol><h2 id="实现">实现</h2><h3 id="启动脚本中添加指定内容">启动脚本中添加指定内容</h3><p>在PTAssist项目的开发中，我们基于kotlin语言开发javafx程序，并通过gradle来进行依赖管理，最终我们使用Application插件的distZip进行项目打包，这会自动生成一个目录结构如下所示的zip文件</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">xxx.zip<br>    |- xxx<br>        |- bin<br>            |- xxx<br>            |- xxx.bat<br>        |- lib<br>            |- aaa.jar<br>            ...<br>            |- nnn.jar<br></code></pre></td></tr></table></figure><p>其中 <code>bin</code> 目录下是对应的启动脚本， <code>lib</code>目录下是程序jar包</p><p>插件默认提供的启动脚本中没有pause命令，所以如果程序出现什么无法启动的错误，就会出现cmd一闪而过的问题，很难排查错误，也不利于用户使用</p><p>于是我们需要在打包的过程中，往启动脚本中注入一行pause</p><p>我们发现，可以通过修改application插件提供的startScripts的Task来手动注入一行pause</p><p>具体代码如下：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs Groovy">tasks.startScripts &#123;<br>    doLast &#123;<br>        <span class="hljs-keyword">def</span> windowsScriptFile = getWindowsScript()<br>        windowsScriptFile.text = windowsScriptFile.text.replace(<span class="hljs-string">&quot;\n:end&quot;</span>, <span class="hljs-string">&quot;pause\n\n:end&quot;</span>)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="zip中添加指定文件">zip中添加指定文件</h3><p>我们的项目需要在打包时加入一个README.md作为用户的使用说明文件</p><p>我们这里采用的是修改distribution插件的配置，因为application插件会自动应用此插件，所以其实可以通过distribution插件的配置来控制application插件的打包内容</p><p>由于默认使用的是 <code>Groovy</code> 的gradle配置文件，所以可以通过<code>Groovy</code>脚本语言提供的功能来自定义的添加需要被打包进入zip的文件或者文件夹</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs Groovy"><span class="hljs-comment">// 打包时加入README.md</span><br><br>distributions &#123;<br>    main &#123;<br>        contents &#123;<br>            from parent.file(<span class="hljs-string">&#x27;README_Client.md&#x27;</span>)<br>            parent.file(<span class="hljs-string">&quot;assets&quot;</span>).listFiles().each &#123;<br>                from(it) &#123;<br>                    into <span class="hljs-string">&quot;assets&quot;</span><br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里通过 <code>parent</code> 获取到了模块对应的项目根目录，然后<code>assets</code>存放的是readme文件所需的图片，所以也需要一并打包进去。</p><p>做完之后，个人觉得，如果最开始采用的是基于kotlin语言的<code>bulid.gradle</code>，那么写这些配置可能会简单一些，而且应该会有比较好的补全。（idea默认不会补全build.gradle里面的groovy的语法，有点蛋疼）</p>]]></content>
    
    
    <categories>
      
      <category>Code</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gradle</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/05/17/hello-world/"/>
    <url>/2023/05/17/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your veryfirst post. Check <a href="https://hexo.io/docs/">documentation</a> formore info. If you get any problems when using Hexo, you can find theanswer in <ahref="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> oryou can ask me on <ahref="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="quick-start">Quick Start</h2><h3 id="create-a-new-post">Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="run-server">Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="generate-static-files">Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="deploy-to-remote-sites">Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <ahref="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
